'''
在不创建分支的前提下, 用一个文件先改好再merge到主文件是最好的选择
————马克·吐温

版本特性:
Debug模式永远是True(测试版嘛毕竟)
【正式版请下载AutoFisching.py】
除了DEBUG提示外几乎无任何多余输出
【正式版请下载AutoFisching.py】
merge到正式版之前的新功能都在这
【正式版请下载AutoFisching.py】
'''
import pydirectinput, time, sys, random, colorama, mss, cv2
import numpy as np
from colorama import Fore, Style, just_fix_windows_console


REEL_REGION = {"top": 1755, "left": 1145, "width": 1547, "height": 81}
PROGRESS_REGION = {"top": 1903, "left": 1502, "width": 835, "height": 17}
lower_blue = np.array([110, 67, 91])
upper_blue = np.array([110, 255, 255])
lower_white = np.array([0, 0, 200])
upper_white = np.array([180, 50, 255])



def init(): # 此函数在脚本运行期间应只需调用一次
    global sct, mouse_is_down, bar_width_history
    just_fix_windows_console()
    sct = mss.mss()
    pydirectinput.PAUSE = 0 # 取消延迟
    mouse_is_down = False # 初始化flag
    bar_width_history = [] # 用于存储白条宽度的历史记录

def log_message(type, message): # 从旧版本直接copy过来的日志输出函数
    time_str=time.strftime("%H:%M:%S", time.localtime())
    if type == "INFO":
        print(f"{Fore.LIGHTGREEN_EX}[{type}]{Style.RESET_ALL} {message}")
    if type == "WARNING":
        print(f"{Fore.LIGHTYELLOW_EX}[{type}]{Style.RESET_ALL} {message}")
    if type == "ERROR":
        print(f"{Fore.RED}[{type}]{Style.RESET_ALL} {message}")
    if type == "DEBUG":
        print(f"{Fore.CYAN}[{type} {Style.RESET_ALL}{time_str}{Fore.CYAN}]{Style.RESET_ALL} {message}") # 当log类型为DEBUG时打印时间

def get_contours(mask):
    # 查找白条的轮廓
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    contours = [cnt for cnt in contours if cv2.contourArea(cnt) > 250] # 过滤掉面积小于250的轮廓
    if contours:
        largest_contour = max(contours, key=cv2.contourArea)# 获取最大轮廓
        x, y, w, h = cv2.boundingRect(largest_contour)# 获取XY长宽
        bar_width_history.append(w)
        if len(bar_width_history) > 10:
            bar_width_history.pop(0)
        # 获取白条平均宽度
        avg_width = int(sum(bar_width_history) / len(bar_width_history))
        return avg_width, x
    return None, None
    
def get_center_x(mask): # 获取掩模中最大轮廓的中心X坐标
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if contours:
        largest_fish = max(contours, key=cv2.contourArea)
        fish_x, fish_y, fish_w, fish_h = cv2.boundingRect(largest_fish)
        fish_center_x = fish_x + fish_w // 2
        return fish_center_x, fish_w
    return None, None

def cast_rod(): # 甩杆
    pydirectinput.mouseDown()
    time.sleep(random.uniform(0.35, 1.40))
    pydirectinput.mouseUp()

init()
time.sleep(2)
cast_rod()
while True:
    # 截图
    img_reel = np.array(sct.grab(REEL_REGION))
    img_progress = np.array(sct.grab(PROGRESS_REGION))
    # 转换至HSV
    hsv_reel = cv2.cvtColor(img_reel, cv2.COLOR_BGRA2BGR) # 钓鱼条
    hsv_reel = cv2.cvtColor(hsv_reel, cv2.COLOR_BGR2HSV)
    hsv_progress = cv2.cvtColor(img_progress, cv2.COLOR_BGRA2BGR) # 进度条
    hsv_progress = cv2.cvtColor(hsv_progress, cv2.COLOR_BGR2HSV)
    # 生成掩模
    mask_fish = cv2.inRange(hsv_reel, lower_blue, upper_blue) # 蓝鱼
    mask_bar = cv2.inRange(hsv_reel, lower_white, upper_white) # 白条
    mask_prog_white = cv2.inRange(hsv_progress, lower_white, upper_white) # 进度条

    white_pixels = cv2.countNonZero(mask_prog_white) # 计算进度条中白色像素的数量
    total_pixels = PROGRESS_REGION["width"] * PROGRESS_REGION["height"] # 计算进度条的总像素数量
    progress_ratio = white_pixels / total_pixels # 计算进度条的比例
    #log_message("DEBUG", f"钓鱼进度: {progress_ratio}")

    combined_mask = cv2.bitwise_or(mask_bar, mask_fish) # 合并白条和蓝鱼
    
    # 形态学处理掩模，去除噪点并填补空洞
    kernel = np.ones((3, 3), np.uint8)
    combined_mask = cv2.morphologyEx(combined_mask, cv2.MORPH_CLOSE, kernel)
    combined_mask = cv2.erode(combined_mask, kernel, iterations=1)

    bar_width, bar_x = get_contours(combined_mask)
    fish_x, fish_w = get_center_x(mask_fish)
    if progress_ratio < 0.98 and progress_ratio >= 0.085: # 已开始钓鱼且进度条未满
        if fish_x != None and bar_width != None and bar_x != None: # 确保非误识别
            if fish_w < 30: # 鱼宽度过大，说明识别到的不是鱼   
                relative_pos = (fish_x - bar_x) / bar_width
                #log_message("DEBUG", f"鱼X={fish_x}, 白条宽={bar_width}, 相对位置={relative_pos:.2f}")
                if relative_pos <= 0.3: # 鱼在白条左侧，向左移动
                    if mouse_is_down:
                        pydirectinput.mouseUp()
                        mouse_is_down = False
                elif relative_pos >= 0.7: # 鱼在白条右侧，向右移动
                    if not mouse_is_down:
                        pydirectinput.mouseDown()
                        mouse_is_down = True
                elif 0.3 < relative_pos < 0.7: # 鱼在白条中间，悬浮
                    if mouse_is_down:
                        pydirectinput.mouseUp()
                        mouse_is_down = False
                    pydirectinput.mouseDown()
                    time.sleep(0.08)
                    pydirectinput.mouseUp()
                    time.sleep(0.01)
    elif progress_ratio < 0.085:
        cast_rod()
        time.sleep(0.5)

    '''
    cv2.imshow("mask_combined", combined_mask)
    cv2.imshow("mask_bar", mask_bar)
    cv2.imshow("mask_prog_white", mask_prog_white)
    cv2.setWindowProperty("mask_combined", cv2.WND_PROP_TOPMOST, 1)
    cv2.setWindowProperty("mask_bar", cv2.WND_PROP_TOPMOST, 2)
    cv2.setWindowProperty("mask_prog_white", cv2.WND_PROP_TOPMOST, 3)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break
    '''

    

    time.sleep(0.01) # 降低CPU占用